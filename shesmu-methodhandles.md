# `MethodHandles` for life-cycle management in Shesmu

At the Ontario Institute for Cancer Research, we decide when to run data analysis workflows based on metadata about previous analysis coupled with patient data. To coordinate that, I build [Shesmu](https://oicr-gsi.shesmu.github.io/) which runs SQL-like programs that select and filter that metadata and create _actions_ that go into a scheduler. For the purpose of this discussion, how the programs are structured and how the scheduler works aren't very relevant. The important part is this: the way that Shesmu programs process data depends heavily on the environment and the Shesmu language is, intentionally, very limited in what it can do. To make the programs useful, a Shesmu server has a lot of plugins and configuration files that make definitions available to those programs.

For a typical deployment, one would deploy the core Shesmu server, a set of plugins (which are Java code), and a directory of configuration files for the plugins. For instance, there is a plugin for interfacing with [Víðarr](https://oicr-gsi.github.io/vidarr/), another in-house service, and that plugin will read any `.vidarr` from the configuration directory and connect to a Víðarr server specified in the configuration. Both development and production Shesmu servers would have the same Java code, but different configuration files and therefore connect to two different Víðarr servers. The Shesmu server can then compile any programs it finds in the configuration directory that might use definitions exported by the plugins. As a concrete example, if a server was configured with a `foo.vidarr` configuration file, then the programs could use the function `vidarr::foo::workflow_run_info`. In effect, the plugins are providing most of the “library” functions that Shesmu programs use.

The Shesmu compiler needs to emit _something_ that will bind to that method and there are two problems: the plugin methods are not static, they are bound to instances of particular plugins (based on what the server finds on disk) and the plugin's configuration might be deleted or recreated. To make that possible, the Shesmu compiler uses the `INVOKEDYNAMIC` and `MethodHandle` infrastructure on the JVM.

There are many descriptions of method handles, but that's not going to stop me from re-explaining. Let's roll back to C for a moment. There are two ways to call a function in C: a regular function call or calling a function pointer. The C compiler will generate two different CPU instructions for those two cases: the first with a hard-coded address and the second with an address loaded from a register or wherever. In Java...life is more complicated. Java has a few different kind of call instructions: `INVOKESTATIC` for calling static methods, `INVOKEVIRTUAL` for calling instance methods of classes, `INVOKEINTERFACE` for doing the same thing as `INVOKEVIRTUAL` but for interfaces, and `INVOKESPECIAL` for calling constructors and `super` methods. In C, the call instruction has the address of a function or the register that contained the address of the function. Again, Java is more complicated. For static methods, constructors, and final instance methods, the JVM could figure out a single address to call; for everything else, not so much. The JVM has to build a data structure to keep track of what code it should call for each of those `INVOKE` instructions and it might change when new classes are loaded.

At some point, the JVM developers were interested in supporting other languages on the JVM which often had calling semantics that were very different from Java's. So, a new instruction `INVOKEDYNAMIC` was created to allow the compiler to figure out what to call later and update it as required. That data structure of what can actually be called is a _method handle_ and the instruction that references it is called the _call site_. Beyond method handles that correspond to the `INVOKE` instructions, there are also method handles to return constants, throw exceptions, access arrays, access fields, and mix and match all these pieces. This was intended so that, in a dynamic language such as Python or Ruby, as new possible subtypes are discovered or created, a call can be expanded to include new behaviours. In Shesmu, I exploit this to marry the plugins and programs together.

Plugins can export definitions to Shesmu programs three ways: annotations on static methods, annotations on instance methods, and using dynamically using callbacks. Each of these is handled slightly differently, though some server infrastructure is managing all of the plugin state in a related way. When Shesmu starts up, it scans for plugins using `ServiceLoader` and then uses the reflection APIs to look for annotations on the plugin classes. It takes an annotated static methods, creates a method handle for these, and puts a definition into the compiler's library. It takes the annotated virtual methods and also creates method handles for those, but puts them in a separate list, not accessible to the compiler.

When the server detects a new configuration file, it finds an appropriate plugin and creates a new instance for it. It names the instance based on the file name. While the file names aren't guaranteed to be unique (the server can scan multiple directories), any administrator who does that is in for a world of hurt, so Shesmu pretends they are unique. It passes the plugin a [`Definer`](https://github.com/oicr-gsi/shesmu/blob/master/shesmu-pluginapi/src/main/java/ca/on/oicr/gsi/shesmu/plugin/Definer.java) instance that allows the plugin to register new definitions that are connected to callbacks. The plugin manager will make the definitions registered using the `Definer` plus any annotated virtual methods available to the compiler. If the configuration file is deleted, the server will remove these from the compiler.

If a program uses an annotated static method, it emits an `INVOKEDYNAMIC` instruction that gets the appropriate method handle from singleton map in the server. Since Java doesn't have the functionality to remove loaded classes, there's no possibility or need to de-register or change these methods. A `ConstantCallSite` is emitted for these since these definitions cannot change.

For definitions tied to an instance, things are a bit trickier. The values registered by `Definer` are the simpler of the two. Like the annotated static method, there is a singleton map in the server. However, since plugins may go away, this map does not point to `ConstantCallSite`, but `SoftReference<MutableCallSite>` (implemented as [`CallSiteRegistry`](https://github.com/oicr-gsi/shesmu/blob/master/shesmu-server/src/main/java/ca/on/oicr/gsi/shesmu/server/plugins/CallSiteRegistry.java)). When the plugin registers a new definition, it will be included in the map and in a list that is exported to the compiler. The compiler will emit an `INVOKEDYNAMIC` instruction that will bind to one of these mutable call sites. As long as at least one of program or the plugin is maintained, the soft reference in the map will contain a mutable call site. If either goes through a life cycle event where it is destroyed, garbage collected, and re-created anew, it will still be connected to the same mutable call site instance, allowing the plugin to update the definition at will.

There is one small wrinkle: type erasure. The Shesmu language has similar erasure behaviour to Java and a plugin could redefine a function that used to return `Set<Long>` to return `Set<String>` and we wouldn't want to use the updated callback in the program. To avoid this the name of a definition in the singleton map includes the type signature. It's effectively C++ name mangling all over again. Working and pretty aren't the same thing.

For annotated virtual methods, the approach is similar: there is a single map of `SoftReference<MutableCallSite>` containing a call site which returns an instance of the plugin. When the compiler needs to create an `INVOKEDYNAMIC` for one of these definitions, it creates a constant call site containing the mutable reference to provide the instance of the plugin, which can be changed, and the virtual method invocation, which cannot be fixed. In essence, it treats the method call itself like the static case and the receiver like the callback case.

If a plugin is unregistered while a program is using it, the program will keep that plugin alive until either the program is removed and both are garbage collected or a replacement plugin comes online. Part of the Shesmu design is that everything should keep on trucking with the last known good state wherever possible. This half-broken state might sound like an uncommon occurrence, but it is sadly common with git-ops. OICR manages the configuration using git and the servers pulls from a git repository containing the files. While git is updating, it transiently deletes files that have changed contents. This design ensures that no running Shesmu programs are affect and all of them will quickly get the new state once it is available. This also gives an administrator a grace period to fix a broken configuration without downtime.

Unlike most programming languages, this does means that Shesmu compile errors are possibly transient. Especially during server start up, plugins may take some time to expose definitions, so programs will fail to compile. The server will reattempt to compile failed programs every few minutes to check if new definitions are available. In this way, Shesmu fulfills every programmer's dream of “maybe it will compile this time even though I haven't changed anything.”
